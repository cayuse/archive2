<div class="player-container">
  <h1>üéµ Jukebox Player</h1>
  
  <!-- Connection Status -->
  <div class="connection-status" id="connection-status">
    <span class="status-indicator"></span>
    <span class="status-text">Connecting...</span>
    <span class="last-update" id="last-update"></span>
  </div>
  
  <!-- Current Song Display -->
  <div class="current-song" id="current-song-display">
    <h3>Now Playing</h3>
    <div class="song-info" id="song-info">
      <div class="song-title">No song playing</div>
      <div class="song-artist"></div>
      <div class="song-album"></div>
    </div>
    
    <!-- Progress Bar -->
    <div class="progress-container">
      <div class="progress-bar">
        <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
      </div>
      <div class="time-display">
        <span id="elapsed-time">0:00</span>
        <span id="total-time">0:00</span>
        <span id="remaining-time">0:00</span>
      </div>
    </div>
  </div>
  
  <!-- Volume Controls -->
  <div class="volume-controls">
    <h3>Volume Control</h3>
    <div class="volume-display">
      <span class="volume-label">Current Volume:</span>
      <span class="volume-value" id="current-volume">80%</span>
    </div>
    <div class="volume-buttons">
      <button class="btn btn-volume" id="volume-down-btn" onclick="sendVolumeCommand('volume_down')">
        üîâ -10
      </button>
      <button class="btn btn-volume" id="volume-up-btn" onclick="sendVolumeCommand('volume_up')">
        üîä +10
      </button>
    </div>
    <div class="volume-slider">
      <div class="volume-form">
        <label for="volume">Set Volume:</label>
        <input type="range" id="volume-slider" name="volume" min="0" max="100" value="80" class="volume-range">
        <span class="volume-display-value" id="volume-slider-value">80%</span>
        <button type="button" class="btn btn-set-volume" onclick="sendVolumeCommand('set_volume')">Set Volume</button>
      </div>
    </div>
  </div>
  
  <!-- Playback Controls -->
  <div class="controls">
    <h3>Playback Controls</h3>
    <div class="control-buttons">
      <button class="btn btn-play" id="play-btn" onclick="sendPlayerCommand('play')">‚ñ∂Ô∏è Play</button>
      <button class="btn btn-pause" id="pause-btn" onclick="sendPlayerCommand('pause')">‚è∏Ô∏è Pause</button>
      <button class="btn btn-stop" id="stop-btn" onclick="sendPlayerCommand('stop')">‚èπÔ∏è Stop</button>
      <button class="btn btn-skip" id="next-btn" onclick="sendPlayerCommand('skip')">‚è≠Ô∏è Skip</button>
    </div>
  </div>
  
  <!-- Real-time Status Display -->
  <div class="status-display">
    <h3>Real-time Status</h3>
    <div class="status-grid">
      <div class="status-item">
        <span class="status-label">Volume:</span>
        <span class="status-value" id="status-volume">80%</span>
      </div>
      <div class="status-item">
        <span class="status-label">State:</span>
        <span class="status-value" id="status-state">unknown</span>
      </div>
      <div class="status-item">
        <span class="status-label">Health:</span>
        <span class="status-value" id="status-health">unknown</span>
      </div>
      <div class="status-item">
        <span class="status-label">Queue Length:</span>
        <span class="status-value" id="status-queue">0</span>
      </div>
    </div>
  </div>
  
  <!-- Debug Display -->
  <div class="debug-display">
    <h3>Debug Info</h3>
    <div class="debug-grid">
      <div class="debug-item">
        <span class="debug-label">Song ID:</span>
        <span class="debug-value" id="debug-song-id">-</span>
      </div>
      <div class="debug-item">
        <span class="debug-label">Song Title:</span>
        <span class="debug-value" id="debug-song-title">-</span>
      </div>
      <div class="debug-item">
        <span class="debug-label">Song Artist:</span>
        <span class="debug-value" id="debug-song-artist">-</span>
      </div>
      <div class="debug-item">
        <span class="debug-label">Song Album:</span>
        <span class="debug-value" id="debug-song-album">-</span>
      </div>
      <div class="debug-item">
        <span class="debug-label">Idle Active:</span>
        <span class="debug-value" id="debug-idle-active">-</span>
      </div>
      <div class="debug-item">
        <span class="debug-label">Paused:</span>
        <span class="debug-value" id="debug-paused">-</span>
      </div>
    </div>
  </div>
</div>

<style>
.player-container { 
  max-width: 800px; 
  margin: 2rem auto; 
  font-family: system-ui, sans-serif; 
  padding: 0 1rem;
}

.connection-status {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 1rem;
  border-radius: 8px;
  margin-bottom: 1rem;
  font-weight: 500;
  background: #f8f9fa;
  border: 1px solid #e9ecef;
}

.connection-status.connected {
  background: #d4edda;
  color: #155724;
  border: 1px solid #c3e6cb;
}

.connection-status.disconnected {
  background: #f8d7da;
  color: #721c24;
  border: 1px solid #f5c6cb;
}

.connection-status.error {
  background: #fff3cd;
  color: #856404;
  border: 1px solid #ffeaa7;
}

.status-indicator {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: currentColor;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0% { opacity: 1; }
  50% { opacity: 0.5; }
  100% { opacity: 1; }
}

.last-update {
  margin-left: auto;
  font-size: 0.8em;
  opacity: 0.7;
}

.current-song {
  background: #f8f9fa;
  padding: 1.5rem;
  border-radius: 8px;
  margin: 1rem 0;
  border: 1px solid #e9ecef;
}

.song-info {
  margin-bottom: 1rem;
}

.song-title {
  font-size: 1.2em;
  font-weight: bold;
  color: #495057;
  margin-bottom: 0.25rem;
}

.song-artist {
  color: #6c757d;
  margin-bottom: 0.25rem;
}

.song-album {
  color: #6c757d;
  font-size: 0.9em;
}

.progress-container {
  margin-top: 1rem;
}

.progress-bar {
  width: 100%;
  height: 8px;
  background: #e9ecef;
  border-radius: 4px;
  overflow: hidden;
  margin-bottom: 0.5rem;
}

.progress-fill {
  height: 100%;
  background: #007bff;
  transition: width 0.3s ease;
}

.time-display {
  display: flex;
  justify-content: space-between;
  font-size: 0.9em;
  color: #6c757d;
}

.volume-controls, .controls, .status-display { 
  background: #f8f9fa; 
  padding: 1.5rem; 
  border-radius: 8px; 
  margin: 1rem 0; 
  border: 1px solid #e9ecef;
}

.volume-controls h3, .controls h3, .status-display h3 {
  margin-top: 0;
  color: #495057;
  border-bottom: 2px solid #dee2e6;
  padding-bottom: 0.5rem;
  margin-bottom: 1rem;
}

.volume-display {
  margin-bottom: 1rem;
}

.volume-buttons {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1rem;
}

.volume-slider {
  display: flex;
  align-items: center;
  gap: 1rem;
  flex-wrap: wrap;
}

.volume-range {
  flex: 1;
  min-width: 200px;
}

.control-buttons {
  display: flex;
  gap: 0.5rem;
  flex-wrap: wrap;
}

.status-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
  margin-top: 1rem;
}

.debug-display {
  margin-top: 2rem;
  padding: 1rem;
  background: #f8f9fa;
  border-radius: 8px;
  border: 1px solid #e9ecef;
}

.debug-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 0.5rem;
  margin-top: 1rem;
}

.debug-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem;
  background: white;
  border-radius: 4px;
  border: 1px solid #dee2e6;
}

.debug-label {
  font-weight: 600;
  color: #495057;
}

.debug-value {
  font-family: monospace;
  color: #6c757d;
  max-width: 200px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.status-item {
  display: flex;
  justify-content: space-between;
  padding: 0.5rem;
  background: white;
  border-radius: 4px;
  border: 1px solid #dee2e6;
}

.status-label {
  font-weight: 500;
  color: #495057;
}

.status-value {
  color: #6c757d;
}

.btn {
  padding: 0.5rem 1rem;
  border: 1px solid #dee2e6;
  border-radius: 4px;
  background: white;
  color: #495057;
  cursor: pointer;
  font-size: 0.9em;
  transition: all 0.2s ease;
}

.btn:hover {
  background: #f8f9fa;
  border-color: #adb5bd;
}

.btn:active {
  transform: translateY(1px);
}

.btn-play { background: #d4edda; border-color: #c3e6cb; color: #155724; }
.btn-pause { background: #fff3cd; border-color: #ffeaa7; color: #856404; }
.btn-stop { background: #f8d7da; border-color: #f5c6cb; color: #721c24; }
.btn-skip { background: #d1ecf1; border-color: #bee5eb; color: #0c5460; }
.btn-volume { background: #e2e3e5; border-color: #d6d8db; color: #383d41; }
.btn-set-volume { background: #007bff; border-color: #007bff; color: white; }

.btn-set-volume:hover { background: #0056b3; border-color: #0056b3; }

/* Mobile responsiveness */
@media (max-width: 768px) {
  .player-container {
    margin: 1rem auto;
    padding: 0 0.5rem;
  }
  
  .volume-slider {
    flex-direction: column;
    align-items: stretch;
  }
  
  .volume-range {
    min-width: auto;
  }
  
  .control-buttons {
    justify-content: center;
  }
  
  .status-grid {
    grid-template-columns: 1fr;
  }
}
</style>

<script>
// Global state for the player
const playerState = {
  isConnected: false,
  errorCount: 0,
  maxErrors: 5,
  lastUpdate: null,
  pollInterval: null,
  commandCounts: {} // Track command counts
};

// Initialize command counters
['play', 'pause', 'stop', 'skip', 'volume_up', 'volume_down', 'set_volume'].forEach(cmd => {
  playerState.commandCounts[cmd] = 0;
});

// Initialize player
document.addEventListener('DOMContentLoaded', function() {
  startPolling();
});

// Start polling for player status
function startPolling() {
  console.log(`üîÑ Starting status polling at ${new Date().toISOString()}`);
  updatePlayerStatus();
  playerState.pollInterval = setInterval(updatePlayerStatus, 1000);
  console.log(`‚è∞ Polling interval set to 1000ms`);
}

// Stop polling (when errors occur)
function stopPolling() {
  console.log(`üõë Stopping status polling at ${new Date().toISOString()}`);
  if (playerState.pollInterval) {
    clearInterval(playerState.pollInterval);
    playerState.pollInterval = null;
    console.log(`‚èπÔ∏è Polling interval cleared`);
  }
}

// Update player status from Redis via Rails API
async function updatePlayerStatus() {
  // Prevent excessive status updates
  const now = Date.now();
  if (window.lastStatusUpdate && (now - window.lastStatusUpdate) < 100) {
    console.log(`‚è≠Ô∏è Status update skipped - too soon after last update (${now - window.lastStatusUpdate}ms)`);
    return;
  }
  window.lastStatusUpdate = now;
  
  console.log(`üìä Updating player status at ${new Date().toISOString()}`);
  
  try {
    const response = await fetch('/api/player/status');
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    const status = await response.json();
    updateDisplay(status);
    playerState.isConnected = true;
    playerState.errorCount = 0;
    playerState.lastUpdate = new Date();
    
    // Update connection status
    updateConnectionStatus('connected');
    console.log(`‚úÖ Status update successful - connected: ${playerState.isConnected}`);
    
  } catch (error) {
    console.error('‚ùå Error updating player status:', error);
    playerState.errorCount++;
    
    if (playerState.errorCount >= playerState.maxErrors) {
      updateConnectionStatus('error');
      stopPolling();
      showError('Connection lost. Please reload the page to reconnect.');
    } else {
      updateConnectionStatus('disconnected');
    }
  }
}

// Update the display with new status data
function updateDisplay(status) {
  // Debug: Log the raw status data
  console.log('üìä Raw status data received:', status);
  
  // Update song information
  updateSongInfo(status);
  
  // Update progress bar and time
  updateProgress(status);
  
  // Update volume display
  updateVolume(status);
  
  // Update status grid
  updateStatusGrid(status);
  
  // Update last update time
  updateLastUpdateTime();
}

// Update song information display
function updateSongInfo(status) {
  const songInfo = document.getElementById('song-info');
  const songTitle = document.querySelector('.song-title');
  const songArtist = document.querySelector('.song-artist');
  const songAlbum = document.querySelector('.song-album');
  
  try {
    // Use new direct fields from player4.py instead of parsing current_song_metadata
    const title = status.song_title;
    const artist = status.song_artist;
    const album = status.song_album;
    
    if (title && title !== 'null' && title !== '') {
      songTitle.textContent = title;
      songArtist.textContent = (artist && artist !== 'null' && artist !== '') ? artist : 'Unknown Artist';
      songAlbum.textContent = (album && album !== 'null' && album !== '') ? album : 'Unknown Album';
      songInfo.style.display = 'block';
    } else {
      songTitle.textContent = 'No song playing';
      songArtist.textContent = '';
      songAlbum.textContent = '';
      songInfo.style.display = 'block';
    }
  } catch (e) {
    console.error('Error updating song info:', e);
    songTitle.textContent = 'No song playing';
    songArtist.textContent = '';
    songAlbum.textContent = '';
    songInfo.style.display = 'block';
  }
}

// Update progress bar and time display
function updateProgress(status) {
  const progressFill = document.getElementById('progress-fill');
  const elapsedTime = document.getElementById('elapsed-time');
  const totalTime = document.getElementById('total-time');
  const remainingTime = document.getElementById('remaining-time');
  
  const elapsed = parseFloat(status.elapsed_seconds || 0);
  const duration = parseFloat(status.duration_seconds || 0);
  const progress = parseFloat(status.progress_percent || 0);
  
  // Update progress bar
  progressFill.style.width = `${progress}%`;
  
  // Update time displays
  elapsedTime.textContent = formatTime(elapsed);
  totalTime.textContent = formatTime(duration);
  remainingTime.textContent = formatTime(duration - elapsed);
}

// Update volume display
function updateVolume(status) {
  const currentVolume = document.getElementById('current-volume');
  const volumeSlider = document.getElementById('volume-slider');
  const volumeSliderValue = document.getElementById('volume-slider-value');
  
  const volume = parseInt(status.volume || 80);
  
  currentVolume.textContent = `${volume}%`;
  volumeSlider.value = volume;
  volumeSliderValue.textContent = `${volume}%`;
}

// Update status grid
function updateStatusGrid(status) {
  const statusVolume = document.getElementById('status-volume');
  const statusState = document.getElementById('status-state');
  const statusHealth = document.getElementById('status-health');
  const statusQueue = document.getElementById('status-queue');
  
  statusVolume.textContent = `${status.volume || 0}%`;
  
  // Show both desired and actual state for better debugging
  const desiredState = status.desired_state || 'unknown';
  const actualState = status.actual_state || 'unknown';
  const idleActive = status.idle_active === 'true';
  const paused = status.paused === 'true';
  
  let stateText = desiredState;
  if (desiredState !== actualState) {
    stateText = `${desiredState} ‚Üí ${actualState}`;
  }
  if (idleActive) {
    stateText += ' (idle)';
  }
  if (paused) {
    stateText += ' (paused)';
  }
  
  statusState.textContent = stateText;
  statusHealth.textContent = status.health || 'unknown';
  
  // Show song ID if available
  const songId = status.song_id;
  if (songId && songId !== 'null' && songId !== '') {
    statusQueue.textContent = `Song #${songId}`;
  } else {
    statusQueue.textContent = 'No song';
  }
  
  // Update debug display
  updateDebugDisplay(status);
}

// Update debug display with raw field values
function updateDebugDisplay(status) {
  const debugSongId = document.getElementById('debug-song-id');
  const debugSongTitle = document.getElementById('debug-song-title');
  const debugSongArtist = document.getElementById('debug-song-artist');
  const debugSongAlbum = document.getElementById('debug-song-album');
  const debugIdleActive = document.getElementById('debug-idle-active');
  const debugPaused = document.getElementById('debug-paused');
  
  debugSongId.textContent = status.song_id || '-';
  debugSongTitle.textContent = status.song_title || '-';
  debugSongArtist.textContent = status.song_artist || '-';
  debugSongAlbum.textContent = status.song_album || '-';
  debugIdleActive.textContent = status.idle_active || '-';
  debugPaused.textContent = status.paused || '-';
}

// Update connection status display
function updateConnectionStatus(status) {
  const connectionStatus = document.getElementById('connection-status');
  const statusText = document.querySelector('.status-text');
  
  connectionStatus.className = `connection-status ${status}`;
  
  switch (status) {
    case 'connected':
      statusText.textContent = 'Connected to Player';
      break;
    case 'disconnected':
      statusText.textContent = 'Connecting...';
      break;
    case 'error':
      statusText.textContent = 'Connection Error';
      break;
  }
}

// Update last update time
function updateLastUpdateTime() {
  const lastUpdate = document.getElementById('last-update');
  if (playerState.lastUpdate) {
    lastUpdate.textContent = `Last: ${playerState.lastUpdate.toLocaleTimeString()}`;
  }
}

// Send player command
async function sendPlayerCommand(action) {
  // Increment command counter
  playerState.commandCounts[action] = (playerState.commandCounts[action] || 0) + 1;
  
  console.log(`üîÑ sendPlayerCommand called with action: "${action}" at ${new Date().toISOString()}`);
  console.log(`üìä Command count for ${action}: ${playerState.commandCounts[action]}`);
  
  // Prevent rapid successive commands
  const now = Date.now();
  if (window.lastCommandTime && (now - window.lastCommandTime) < 1000) {
    console.warn(`‚ö†Ô∏è Command "${action}" ignored - too soon after last command (${now - window.lastCommandTime}ms)`);
    return;
  }
  window.lastCommandTime = now;
  
  try {
    console.log(`üì§ Sending ${action} command to /system/${action}`);
    const response = await fetch(`/system/${action}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content')
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    const result = await response.json();
    console.log(`‚úÖ ${action} command successful:`, result);
    
    // Update status immediately after command
    setTimeout(updatePlayerStatus, 100);
    
  } catch (error) {
    console.error(`‚ùå Error sending ${action} command:`, error);
    showError(`Failed to send ${action} command`);
  }
}

// Send volume command
async function sendVolumeCommand(action) {
  console.log(`üîä sendVolumeCommand called with action: "${action}" at ${new Date().toISOString()}`);
  
  // Prevent rapid successive volume commands
  const now = Date.now();
  if (window.lastVolumeCommandTime && (now - window.lastVolumeCommandTime) < 500) {
    console.warn(`‚ö†Ô∏è Volume command "${action}" ignored - too soon after last volume command (${now - window.lastVolumeCommandTime}ms)`);
    return;
  }
  window.lastVolumeCommandTime = now;
  
  try {
    let url = `/system/${action}`;
    let body = null;
    
    if (action === 'set_volume') {
      const volume = document.getElementById('volume-slider').value;
      url = '/system/set_volume';
      body = JSON.stringify({ volume: parseInt(volume) });
      console.log(`üì§ Setting volume to ${volume}% via /system/set_volume`);
    } else {
      console.log(`üì§ Sending volume command to /system/${action}`);
    }
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content')
      },
      body: body
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    const result = await response.json();
    console.log(`‚úÖ Volume command "${action}" successful:`, result);
    
    // Update status immediately after command
    setTimeout(updatePlayerStatus, 100);
    
  } catch (error) {
    console.error(`‚ùå Error sending volume command "${action}":`, error);
    showError(`Failed to send volume command`);
  }
}

// Format time in MM:SS format
function formatTime(seconds) {
  if (!seconds || isNaN(seconds)) return '0:00';
  
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

// Show error message
function showError(message) {
  console.error(message);
  // You could add a toast notification here if desired
}

// Handle volume slider change
document.getElementById('volume-slider').addEventListener('input', function() {
  const value = this.value;
  document.getElementById('volume-slider-value').textContent = `${value}%`;
});

// Display command counts for debugging
function showCommandCounts() {
  console.log(`üìä Current command counts:`, playerState.commandCounts);
  
  // Create or update debug display
  let debugDiv = document.getElementById('command-debug');
  if (!debugDiv) {
    debugDiv = document.createElement('div');
    debugDiv.id = 'command-debug';
    debugDiv.style.cssText = 'position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.8); color: white; padding: 10px; border-radius: 5px; font-family: monospace; font-size: 12px; z-index: 1000;';
    document.body.appendChild(debugDiv);
  }
  
  const counts = Object.entries(playerState.commandCounts)
    .map(([cmd, count]) => `${cmd}: ${count}`)
    .join('<br>');
  
  debugDiv.innerHTML = `<strong>Command Counts:</strong><br>${counts}`;
}

// Call this function periodically to update the display
setInterval(showCommandCounts, 2000);
</script>


