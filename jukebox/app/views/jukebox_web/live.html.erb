<div class="container">
  <div class="row">
    <div class="col-12">
      <h1 class="mb-4">Live Jukebox</h1>
      
      <!-- Now Playing Card -->
      <div class="card mb-4">
        <div class="card-header">
          <h5 class="mb-0">
            <i class="fas fa-play-circle me-2"></i>
            Now Playing
          </h5>
        </div>
        <div class="card-body">
          <!-- Current Song Display (matches /system/player exactly) -->
          <div class="current-song" id="live-current-song-display">
            <div class="song-info" id="live-song-info" style="display: block;">
              <div class="song-title theme-text-primary">No song playing</div>
              <div class="song-artist theme-text-secondary"></div>
              <div class="song-album theme-text-muted"></div>
            </div>
            
            <!-- Progress Bar -->
            <div class="progress-container">
              <div class="progress-bar">
                <div class="progress-fill" id="live-progress-fill" style="width: 0%"></div>
              </div>
              <div class="time-display">
                <span id="live-elapsed-time">0:00</span>
                <span id="live-total-time">0:00</span>
                <span id="live-remaining-time">0:00</span>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Upcoming Songs -->
      <div class="card">
        <div class="card-header d-flex justify-content-between align-items-center">
          <h5 class="mb-0">
            <i class="fas fa-list me-2"></i>
            Upcoming Songs
          </h5>
          <div>
            <span class="badge bg-primary me-2" id="upcoming-count">0 songs</span>
            <button class="btn btn-sm btn-outline-secondary" onclick="refreshUpcomingSongs()">
              <i class="fas fa-sync-alt"></i> Refresh
            </button>
          </div>
        </div>
        <div class="card-body">
          <div id="upcoming-songs-content">
            <div class="text-center py-4">
              <i class="fas fa-spinner fa-spin fa-3x text-muted mb-3"></i>
              <h5 class="text-muted">Loading upcoming songs...</h5>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- JavaScript for Live Updates -->
<script>
// Live view state management
const liveState = {
  isConnected: false,
  errorCount: 0,
  maxErrors: 5,
  lastUpdate: null,
  pollInterval: null,
  upcomingInterval: null
};

// Initialize live view
document.addEventListener('DOMContentLoaded', function() {
  console.log('Live view initialized');
  startLiveUpdates();
  startUpcomingUpdates();
});

// Start live updates (1 second intervals)
function startLiveUpdates() {
  console.log('üîÑ Starting live updates');
  updateLiveStatus();
  liveState.pollInterval = setInterval(updateLiveStatus, 1000);
}

// Start upcoming songs updates (10 second intervals)
function startUpcomingUpdates() {
  console.log('üîÑ Starting upcoming songs updates');
  updateUpcomingSongs();
  liveState.upcomingInterval = setInterval(updateUpcomingSongs, 10000);
}

// Update live player status
async function updateLiveStatus() {
  try {
    const response = await fetch('/live/status');
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    const data = await response.json();
    console.log('üìä Live status update:', data);
    
    updateLiveDisplay(data);
    liveState.isConnected = true;
    liveState.errorCount = 0;
    liveState.lastUpdate = new Date();
    
  } catch (error) {
    console.error('‚ùå Error updating live status:', error);
    liveState.errorCount++;
    
    if (liveState.errorCount >= liveState.maxErrors) {
      console.error('üö® Too many errors, stopping live updates');
      stopLiveUpdates();
    }
  }
}

// Update upcoming songs
async function updateUpcomingSongs() {
  try {
    const response = await fetch('/live/upcoming');
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    const data = await response.json();
    console.log('üìã Upcoming songs update:', data);
    
            updateUpcomingDisplay(data.upcoming_songs, data.logged_in);
    
  } catch (error) {
    console.error('‚ùå Error updating upcoming songs:', error);
  }
}

// Manual refresh of upcoming songs
function refreshUpcomingSongs() {
  console.log('üîÑ Manual refresh of upcoming songs');
  updateUpcomingSongs();
}

// Update live display with player status
function updateLiveDisplay(data) {
  const playerStatus = data.player_status;
  
  console.log('Updating live display:', { playerStatus });
  
  // Update song information from player status (same as system player)
  updateLiveSongInfo(playerStatus);
  
  // Update progress bar and time from player status
  updateLiveProgress(playerStatus);
}

// Update live song information
function updateLiveSongInfo(playerStatus) {
  const songInfo = document.getElementById('live-song-info');
  
  if (playerStatus && playerStatus.song_title) {
    songInfo.innerHTML = `
      <div class="song-title theme-text-primary">${playerStatus.song_title}</div>
      ${playerStatus.song_artist ? `<div class="song-artist theme-text-secondary">${playerStatus.song_artist}</div>` : '<div class="song-artist theme-text-muted">Unknown Artist</div>'}
      ${playerStatus.song_album ? `<div class="song-album theme-text-muted">${playerStatus.song_album}</div>` : '<div class="song-album theme-text-muted">Unknown Album</div>'}
    `;
  } else {
    songInfo.innerHTML = `
      <div class="song-title theme-text-primary">No song playing</div>
      <div class="song-artist theme-text-secondary"></div>
      <div class="song-album theme-text-muted"></div>
    `;
  }
}

// Update live progress bar and time display
function updateLiveProgress(playerStatus) {
  const progressFill = document.getElementById('live-progress-fill');
  const elapsedTime = document.getElementById('live-elapsed-time');
  const totalTime = document.getElementById('live-total-time');
  const remainingTime = document.getElementById('live-remaining-time');
  
  const elapsed = parseFloat(playerStatus.elapsed_seconds || 0);
  const duration = parseFloat(playerStatus.duration_seconds || 0);
  const progress = parseFloat(playerStatus.progress_percent || 0);
  
  console.log('‚è±Ô∏è Progress update:', { elapsed, duration, progress });
  
  // Update progress bar
  progressFill.style.width = `${progress}%`;
  
  // Update time displays
  elapsedTime.textContent = formatTime(elapsed);
  totalTime.textContent = formatTime(duration);
  remainingTime.textContent = formatTime(duration - elapsed);
}

// Update upcoming songs display
function updateUpcomingDisplay(upcomingSongs, loggedIn = false) {
  const content = document.getElementById('upcoming-songs-content');
  const count = document.getElementById('upcoming-count');
  
  count.textContent = `${upcomingSongs.length} songs`;
  
  if (upcomingSongs.length > 0) {
    content.innerHTML = `
      <div class="table-responsive">
        <table class="table table-hover">
          <thead>
            <tr>
              <th style="width: 50px;">#</th>
              <th>Song</th>
              <th>Artist</th>
              <th>Album</th>
              <th style="width: 100px;">Duration</th>
              <th style="width: 80px;">Source</th>
              ${loggedIn ? '<th style="width: 80px;">Actions</th>' : ''}
            </tr>
          </thead>
          <tbody>
            ${upcomingSongs.map((item, index) => `
              <tr>
                <td>
                  <span class="badge bg-secondary">${index + 1}</span>
                </td>
                <td>
                  <strong style="color: #1f2937;">${item.song.title}</strong>
                </td>
                <td>
                  <span style="color: #1f2937;">${item.song.artist_name || 'Unknown Artist'}</span>
                </td>
                <td>
                  <span style="color: #1f2937;">${item.song.album_name || 'Unknown Album'}</span>
                </td>
                <td>
                  <span style="color: #1f2937;">${item.song.duration ? formatDuration(item.song.duration) : '-'}</span>
                </td>
                <td>
                  <span class="badge ${item.source === 'random' ? 'bg-success' : 'bg-info'}" title="Order #${item.order_number}">
                    ${item.source === 'random' ? 'Random' : 'Queue'}
                  </span>
                </td>
                ${loggedIn ? `
                  <td>
                    <div class="btn-group btn-group-sm" role="group">
                      <button type="button" class="btn btn-outline-primary btn-sm" 
                              onclick="moveSongToTop(${item.order_number})" 
                              title="Move to top of queue">
                        ‚¨ÜÔ∏è
                      </button>
                      <button type="button" class="btn btn-outline-danger btn-sm" 
                              onclick="removeSongFromQueue(${item.order_number})" 
                              title="Remove from queue">
                        ‚ùå
                      </button>
                    </div>
                  </td>
                ` : ''}
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
    `;
  } else {
    content.innerHTML = `
      <div class="text-center py-4">
        <i class="fas fa-list fa-3x text-muted mb-3"></i>
        <h5 class="text-muted">No upcoming songs</h5>
        <p class="text-muted">Add songs to the queue to see upcoming tracks</p>
      </div>
    `;
  }
}

// Utility function to format time
function formatTime(seconds) {
  if (!seconds || seconds < 0) return '0:00';
  
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

// Utility function to format duration (assuming it's in seconds)
function formatDuration(duration) {
  if (!duration) return '';
  return formatTime(duration);
}

// Move a song to the top of the queue
async function moveSongToTop(orderNumber) {
  try {
    const response = await fetch('/songs/move_to_top', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content')
      },
      body: JSON.stringify({ order_number: orderNumber })
    });
    
    const result = await response.json();
    
    if (result.success) {
      console.log('‚úÖ Song moved to top:', result.message);
      // Refresh the upcoming songs display
      updateUpcomingSongs();
    } else {
      console.error('‚ùå Failed to move song:', result.message);
      alert('Failed to move song to top: ' + result.message);
    }
  } catch (error) {
    console.error('‚ùå Error moving song to top:', error);
    alert('Error moving song to top. Please try again.');
  }
}

// Remove a song from the queue
async function removeSongFromQueue(orderNumber) {
  if (!confirm('Are you sure you want to remove this song from the queue?')) {
    return;
  }
  
  try {
    const response = await fetch('/songs/remove_from_queue', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content')
      },
      body: JSON.stringify({ order_number: orderNumber })
    });
    
    const result = await response.json();
    
    if (result.success) {
      console.log('‚úÖ Song removed from queue:', result.message);
      // Refresh the upcoming songs display
      updateUpcomingSongs();
    } else {
      console.error('‚ùå Failed to remove song:', result.message);
      alert('Failed to remove song: ' + result.message);
    }
  } catch (error) {
    console.error('‚ùå Error removing song:', error);
    alert('Error removing song. Please try again.');
  }
}

// Stop live updates
function stopLiveUpdates() {
  if (liveState.pollInterval) {
    clearInterval(liveState.pollInterval);
    liveState.pollInterval = null;
  }
  if (liveState.upcomingInterval) {
    clearInterval(liveState.upcomingInterval);
    liveState.upcomingInterval = null;
  }
  console.log('üõë Live updates stopped');
}

// Cleanup on page unload
window.addEventListener('beforeunload', function() {
  stopLiveUpdates();
});
</script>

 